#!/usr/bin/env python
import os
from importlib import import_module
import argparse as ap
import logging
from dateutil import tz
from datetime import datetime
import collections as col

from tools import scanner, reader
from graphic import html as dphtml

logger = logging.getLogger(os.path.basename(__file__))
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

MEASUREMENT_INFO = {
    'Active Measures' : [
        'phone.surveyAnswers.surveyAnswers',
        'phone.voiceRecording.record_duration'
    ],
    'Passive Measures' : [
        'phone.callLog.Totalduration',
        'phone.textsLog.Totallength',
        'phone.gps.dist_from_home',
        'phone.accel.rms',
        'actigraphy.ActiWatch2.activity',
        'actigraphy.ActiWatch2.light'
    ],
    'Study Visit Measures' : [
    ]
}

def main():    
    argparser = ap.ArgumentParser('DPreport Pipeline')
    
    # Input and output parameters
    argparser.add_argument('--root-dir', default='/ncf/cnl03/PHOENIX',
        help='Path to the input directory (default: /ncf/cnl03/PHOENIX)')
    argparser.add_argument('--output-dir', help='Path to the output directory (optional);')
    argparser.add_argument('--consent-dir', help='Directory that has the metadata file named: STUDY.csv; Default: GENERAL', default='GENERAL')

    argparser.add_argument('--data-type', nargs='+', help='Names of the data types to run this pipeline on (ex. actigraphy, phone)')
    argparser.add_argument('--process', nargs='+', help='Process data, png, and/or html', default=['data', 'png', 'html'])

    # Basic targeting parameters
    argparser.add_argument('--study', nargs='+', help='Study name')
    argparser.add_argument('--subject', nargs='+', help='Subject ID')
    argparser.add_argument('--timezone', default = 'America/New_York')

    args = argparser.parse_args()

    # We'll get the consent information first, then loop through all subdirectories under the root directory.
    default_path = os.path.join(args.root_dir, args.consent_dir)


    passphrases = get_passphrases()
    if len(passphrases) == 0:
        logger.error('Passphrases unavailable. DPreport will skip data that requires a passphrase to unlock.')

    # Gets all studies under each subdirectory
    studies = args.study if args.study else scanner.scan_dir(default_path)
    for study in studies:
        study_path = os.path.join(default_path, study)

        # Grab consent date from the metadata
        consents = read_metadata(study, study_path)
        if len(consents) == 0:
            logger.error('Consent information for {STUDY} is not available. Skipping the study.'.format(STUDY=study))
            continue

        passphrase = passphrases[study] if study in passphrases else None

        # Gets all subjects under the study directory
        subjects = args.subject if args.subject else scanner.scan_dir(study_path)
        for subject in subjects:
            # Ensures the subject directory is not the consent directory
            if subject.endswith('.csv'): 
                continue

            logger.info('Processing {SUBJECT} in {STUDY}'.format(SUBJECT=subject, STUDY=study))
            subject_path = os.path.join(study_path, subject)

            date_from = parse_consents(consents, subject, study)
            if date_from is None:
                continue

            directories = scanner.scan_dir(args.root_dir)
            # Loops through PHOENIX's subdirectories.
            # Scans GENERAL and PROTECTED by default
            for directory in sorted(directories):
                subject_path = os.path.join(args.root_dir, directory, study, subject)

                # Scan each subject's directory to find available data types
                data_types = args.data_type if args.data_type else scanner.scan_dir(subject_path)
                for data_type in data_types:
                    data_path = os.path.join(subject_path, data_type)

                    # Import the module and process
                    mod = scanner.scan_library(data_type)
                    if mod is None:
                        continue
                    else:
                        write_path = args.output_dir if args.output_dir else os.path.join(data_path, 'processed')
                        if 'data' in (x.lower() for x in args.process):
                            mod.process(study, subject, data_type, data_path, date_from, args.timezone, write_path, passphrase)
                        if 'png' in (x.lower() for x in args.process):
                            mod.run_gplot(write_path, study, subject, data_path, data_type)
                        if 'html' in (x.lower() for x in args.process):
                            dphtml.generate(MEASUREMENT_INFO, study, subject, args.timezone, write_path, args.root_dir)

def get_passphrases():
    passphrases = col.defaultdict()

    if os.getenv('dpreport_pp'):
        passphrase_path = os.getenv('dpreport_pp')
        for row in reader.read_csv(passphrase_path, 0):
            if 'study' not in row or 'passphrase' not in row:
                logger.error('Mal-formatted passphrase file.')
                break
            study = row['study']
            passphrases[study] = row['passphrase']
        return passphrases
    else:
        return passphrases

def parse_consents(consents, subject, study):
    # Check the subject's consent information and the format of the consent date
    # Assumes the consent date is in EST/EDT timezone
    logger.info('Processing the consent date of {SUBJECT} in {STUDY}'.format(SUBJECT=subject, STUDY=study))
    if subject in consents:
        consent_date = consents[subject]['Consent']
        try:
            return datetime.strptime(consent_date, '%Y-%m-%d').replace(tzinfo=tz.gettz('America/New_York'))
        except Exception as e:
            logger.error(e)
            logger.error('Error occurred while parsing the consent information for {}. Moving on.'.format(subject))
            return None
    else:
        logger.error('The consent date is not available for {SUBJECT} in {STUDY}. Skipping the subject.'.format(SUBJECT=subject, STUDY=study))
        return None

def read_metadata(study, study_path):
    # Read in metadata file for the study
    logger.info('Reading in metadata file for study {STUDY}'.format(STUDY=study))
    study_metadata_path = os.path.join(study_path, '{STUDY}.csv'.format(STUDY=study))

    # Grab consent date from the metadata
    consents = col.defaultdict()
    for row in reader.read_csv(study_metadata_path, 0):
        sid = row['Subject ID']
        consents[sid] = row

    return consents

if __name__ == '__main__':
    main()
